<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake: Pro AI Edition</title>
    <style>
        :root {
            --bg: #020617;
            --card: #0f172a;
            --primary: #10b981;
            --secondary: #3b82f6;
            --accent: #f43f5e;
            --text: #f8fafc;
            --border: #1e293b;
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', -apple-system, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #bg-pattern {
            position: fixed;
            inset: 0;
            background-image: linear-gradient(var(--border) 1px, transparent 1px), linear-gradient(90deg, var(--border) 1px, transparent 1px);
            background-size: 40px 40px;
            opacity: 0.1;
            z-index: -1;
        }

        .screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            z-index: 10;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        .logo-text {
            font-size: clamp(3.5rem, 15vw, 5rem);
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        .btn {
            background: var(--primary);
            color: var(--bg);
            border: none;
            padding: 20px 60px;
            font-size: 1.3rem;
            font-weight: 800;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.3);
            cursor: pointer;
            text-transform: uppercase;
        }

        #game-screen {
            justify-content: space-between;
            padding: env(safe-area-inset-top, 10px) 10px env(safe-area-inset-bottom, 10px);
        }

        .game-header {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .game-bar {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .pill {
            background: var(--card);
            border: 2px solid var(--border);
            padding: 14px;
            border-radius: 18px;
            font-size: 0.9rem;
            font-weight: 800;
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex: 1;
        }

        .pill.active {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(16, 185, 129, 0.1);
        }

        .score-info {
            display: flex;
            justify-content: space-between;
            padding: 0 5px;
            font-weight: 900;
            font-size: 1.1rem;
            text-transform: uppercase;
        }

        .canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        #game-canvas {
            background: #000;
            border: 4px solid var(--border);
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .shake { animation: shake-anim 0.4s both; }
        @keyframes shake-anim {
            0%, 100% { transform: translate(0,0); }
            20% { transform: translate(-6px, 0); }
            40% { transform: translate(6px, 0); }
            60% { transform: translate(-6px, 0); }
            80% { transform: translate(6px, 0); }
        }

        .diff-card {
            background: var(--card);
            border: 2px solid var(--border);
            width: 100%;
            max-width: 350px;
            padding: 25px;
            border-radius: 24px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toast {
            position: fixed;
            top: 20px;
            background: var(--secondary);
            padding: 12px 24px;
            border-radius: 50px;
            font-weight: 800;
            transform: translateY(-150px);
            transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            z-index: 1000;
        }
        #toast.show { transform: translateY(0); }
    </style>
</head>
<body>

    <div id="bg-pattern"></div>
    <div id="toast">NEW RECORD! ðŸ‘‘</div>

    <section id="home-screen" class="screen">
        <h1 class="logo-text">SNAKE</h1>
        <p style="letter-spacing: 5px; color: var(--primary); font-weight: 900; margin-bottom: 40px; font-size: 0.8rem;">PRO AI EDITION</p>
        <button class="btn" onclick="showScreen('diff-screen')">START</button>
        <p style="margin-top: 40px; font-weight: 800; color: #64748b;">RECORD: <span id="home-best" style="color:white">0</span></p>
    </section>

    <section id="diff-screen" class="screen hidden">
        <h2 style="font-weight: 900; margin-bottom: 30px;">DIFFICULTY</h2>
        <div class="diff-card" onclick="startGame(200)">
            <h3 style="margin:0">CHILL</h3>
            <span style="color:var(--primary)">PLAY</span>
        </div>
        <div class="diff-card" onclick="startGame(130)">
            <h3 style="margin:0">SWIFT</h3>
            <span style="color:var(--primary)">PLAY</span>
        </div>
        <div class="diff-card" onclick="startGame(60)">
            <h3 style="margin:0">HYPER</h3>
            <span style="color:var(--primary)">PLAY</span>
        </div>
        <button style="margin-top: 20px; background:none; border:none; color:#64748b; font-weight:800;" onclick="showScreen('home-screen')">BACK</button>
    </section>

    <section id="game-screen" class="screen hidden">
        <div class="game-header">
            <div class="game-bar">
                <div class="pill" onclick="togglePause()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><rect x="4" y="4" width="16" height="16" rx="2"/></svg>
                    <span id="p-text">PAUSE</span>
                </div>
                <div class="pill" id="auto-btn" onclick="toggleAuto()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                    PRO AI
                </div>
            </div>
            <div class="score-info">
                <span>SCORE: <span id="cur-score" style="color: white">0</span></span>
                <span>BEST: <span id="hi-score" style="color: white">0</span></span>
            </div>
        </div>
        
        <div class="canvas-wrapper">
            <canvas id="game-canvas"></canvas>
        </div>
    </section>

    <section id="game-over" class="screen hidden" style="background: rgba(2,6,23,0.98); z-index: 100;">
        <h1 style="color: var(--accent); font-size: 3.5rem; font-weight: 900;">FAILED</h1>
        <p id="final-score" style="font-size: 1.5rem; margin-bottom: 40px; font-weight: 700;">Score: 0</p>
        <button class="btn" onclick="showScreen('diff-screen')">RETRY</button>
        <button style="margin-top: 25px; background:none; border:none; color:#64748b; font-weight:800;" onclick="showScreen('home-screen')">EXIT</button>
    </section>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const homeBest = document.getElementById('home-best');
        const gameHi = document.getElementById('hi-score');
        const scoreCur = document.getElementById('cur-score');
        const autoBtn = document.getElementById('auto-btn');
        const pText = document.getElementById('p-text');

        let tiles = 20; 
        let grid = 20; 
        
        let snake = [];
        let food = {x: 5, y: 5};
        let particles = [];
        let dx = 0, dy = -1;
        let nextDx = 0, nextDy = -1;
        let score = 0;
        let hi = localStorage.getItem('snk_pro_ai_hi') || 0;
        let lastTick = 0;
        let speed = 130;
        let isAuto = false;
        let isPaused = false;
        let active = false;

        homeBest.innerText = hi;

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
            active = false;
            isPaused = false;
            isAuto = false;
            autoBtn.classList.remove('active');
            pText.innerText = "PAUSE";
            canvas.classList.remove('shake');
        }

        function togglePause() { 
            isPaused = !isPaused; 
            pText.innerText = isPaused ? "RESUME" : "PAUSE";
        }
        
        function toggleAuto() { 
            isAuto = !isAuto; 
            autoBtn.classList.toggle('active', isAuto);
        }

        function startGame(s) {
            resize(); 
            speed = s;
            showScreen('game-screen');
            snake = [{x: 10, y: 10}, {x: 10, y: 11}, {x: 10, y: 12}];
            dx = 0; dy = -1;
            nextDx = 0; nextDy = -1;
            score = 0;
            scoreCur.innerText = score;
            gameHi.innerText = hi;
            particles = [];
            spawnFood();
            active = true;
            lastTick = performance.now();
            requestAnimationFrame(engine);
        }

        function spawnFood() {
            food = { 
                x: Math.floor(Math.random() * tiles), 
                y: Math.floor(Math.random() * tiles) 
            };
            if(snake.some(p => p.x === food.x && p.y === food.y)) spawnFood();
        }

        function createBurst(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: x * grid + grid/2,
                    y: y * grid + grid/2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        // --- NEW PRO AI LOGIC ---
        function runProAI() {
            const head = snake[0];
            const possibleMoves = [
                {x: 0, y: -1}, {x: 0, y: 1}, 
                {x: -1, y: 0}, {x: 1, y: 0}
            ];

            // 1. Filter out immediate collisions (No 180-degree turns)
            const validMoves = possibleMoves.filter(m => !(m.x === -dx && m.y === -dy));

            // 2. Score moves based on safety and food proximity
            const moveScores = validMoves.map(move => {
                const nextPos = {
                    x: (head.x + move.x + tiles) % tiles,
                    y: (head.y + move.y + tiles) % tiles
                };

                let score = 0;

                // Penalty: Collision with self
                const selfCollision = snake.some(p => p.x === nextPos.x && p.y === nextPos.y);
                if (selfCollision) {
                    score -= 10000;
                }

                // Reward: Closer to food
                const dist = Math.abs(nextPos.x - food.x) + Math.abs(nextPos.y - food.y);
                score -= dist;

                // CRITICAL: Lookahead Safety (Flood-fill style check)
                // If this move leads to a confined space, penalize heavily
                if (!selfCollision) {
                    const accessibleSpace = countAccessibleSpace(nextPos);
                    if (accessibleSpace < snake.length) {
                        score -= 5000; // Dangerous dead-end
                    }
                }

                return { move, score };
            });

            // 3. Choose the best move
            moveScores.sort((a, b) => b.score - a.score);
            nextDx = moveScores[0].move.x;
            nextDy = moveScores[0].move.y;
        }

        // Simple BFS to count free space available from a position
        function countAccessibleSpace(startPos) {
            let visited = new Set();
            let queue = [startPos];
            let count = 0;
            const maxCheck = 50; // Optimization: only check enough space for the snake

            while (queue.length > 0 && count < maxCheck) {
                let curr = queue.shift();
                let key = `${curr.x},${curr.y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                const isCollision = snake.some(p => p.x === curr.x && p.y === curr.y);
                if (isCollision) continue;

                count++;

                const neighbors = [
                    {x: (curr.x + 1) % tiles, y: curr.y},
                    {x: (curr.x - 1 + tiles) % tiles, y: curr.y},
                    {x: curr.x, y: (curr.y + 1) % tiles},
                    {x: curr.x, y: (curr.y - 1 + tiles) % tiles}
                ];

                neighbors.forEach(n => queue.push(n));
            }
            return count;
        }

        function logic() {
            if (isPaused || !active) return;
            if (isAuto) runProAI();
            dx = nextDx; dy = nextDy;

            const head = { x: (snake[0].x + dx + tiles) % tiles, y: (snake[0].y + dy + tiles) % tiles };
            
            if (snake.some(p => p.x === head.x && p.y === head.y)) return crash();

            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreCur.innerText = score;
                createBurst(food.x, food.y, '#f43f5e');
                spawnFood();
            } else {
                snake.pop();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy;
                p.life -= 0.04;
                if(p.life <= 0) { particles.splice(i, 1); return; }
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
            });
            ctx.globalAlpha = 1.0;

            ctx.shadowBlur = 15;
            ctx.shadowColor = '#f43f5e';
            ctx.fillStyle = '#f43f5e';
            ctx.beginPath();
            ctx.roundRect(food.x * grid + 4, food.y * grid + 4, grid - 8, grid - 8, 4);
            ctx.fill();

            snake.forEach((p, i) => {
                const isHead = i === 0;
                ctx.shadowBlur = isHead ? 20 : 0;
                ctx.shadowColor = '#10b981';
                ctx.fillStyle = isHead ? '#10b981' : '#064e3b';
                
                ctx.beginPath();
                const pad = 1.5;
                ctx.roundRect(p.x * grid + pad, p.y * grid + pad, grid - pad*2, grid - pad*2, isHead ? 8 : 4);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function engine(time) {
            if (!active) return;
            const delta = time - lastTick;
            if (delta >= speed) {
                logic();
                lastTick = time;
            }
            draw();
            requestAnimationFrame(engine);
        }

        function crash() {
            active = false;
            canvas.classList.add('shake');
            snake.forEach(p => createBurst(p.x, p.y, '#10b981'));
            
            setTimeout(() => {
                document.getElementById('final-score').innerText = `Final Score: ${score}`;
                document.getElementById('game-over').classList.remove('hidden');
                if (score > hi) {
                    hi = score;
                    localStorage.setItem('snk_pro_ai_hi', hi);
                    homeBest.innerText = hi;
                    document.getElementById('toast').classList.add('show');
                    setTimeout(() => document.getElementById('toast').classList.remove('show'), 3000);
                }
            }, 600);
        }

        let sX = 0, sY = 0;
        document.addEventListener('touchstart', e => { 
            sX = e.touches[0].clientX; 
            sY = e.touches[0].clientY; 
        }, {passive:false});

        document.addEventListener('touchmove', e => {
            if (!sX || !sY || isAuto || isPaused) return;
            const xDiff = sX - e.touches[0].clientX;
            const yDiff = sY - e.touches[0].clientY;
            if (Math.abs(xDiff) > 15 || Math.abs(yDiff) > 15) {
                if (Math.abs(xDiff) > Math.abs(yDiff)) {
                    if (xDiff > 0 && dx === 0) { nextDx = -1; nextDy = 0; }
                    else if (xDiff < 0 && dx === 0) { nextDx = 1; nextDy = 0; }
                } else {
                    if (yDiff > 0 && dy === 0) { nextDx = 0; nextDy = -1; }
                    else if (yDiff < 0 && dy === 0) { nextDx = 0; nextDy = 1; }
                }
                sX = e.touches[0].clientX; sY = e.touches[0].clientY;
            }
        }, {passive:false});

        function resize() {
            const wrap = document.querySelector('.canvas-wrapper');
            const availableW = wrap.clientWidth - 20;
            const availableH = wrap.clientHeight - 20;
            const maxSquareSize = Math.floor(Math.min(availableW, availableH) / tiles);
            grid = maxSquareSize;
            const totalSize = grid * tiles;
            canvas.width = totalSize;
            canvas.height = totalSize;
            canvas.style.width = totalSize + "px";
            canvas.style.height = totalSize + "px";
        }
        
        window.onresize = resize;
        resize();
    </script>
</body>
</html>